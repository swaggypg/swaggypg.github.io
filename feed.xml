<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator><link href="/jekyll-theme-yat/feed.xml" rel="self" type="application/atom+xml" /><link href="/jekyll-theme-yat/" rel="alternate" type="text/html" hreflang="zh-CN" /><updated>2025-07-06T13:28:25+08:00</updated><id>/jekyll-theme-yat/feed.xml</id><title type="html">Do not go gentle into that good night</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><author><name>Lin</name></author><entry><title type="html">2024 年 度 总 结</title><link href="/jekyll-theme-yat/%E6%9D%82%E8%B0%88/2025/02/07/2024%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="2024 年 度 总 结" /><published>2025-02-07T00:00:00+08:00</published><updated>2025-02-07T00:00:00+08:00</updated><id>/jekyll-theme-yat/%E6%9D%82%E8%B0%88/2025/02/07/2024%E6%80%BB%E7%BB%93</id><content type="html" xml:base="/jekyll-theme-yat/%E6%9D%82%E8%B0%88/2025/02/07/2024%E6%80%BB%E7%BB%93.html"><![CDATA[<blockquote>
  <p>愿君长似少年时，初心不忘乐相知。</p>
</blockquote>

<p>原本以为在知名互联网公司实习的经历能让我在春招中拿到更多的主动权，但事实还是给我上了一课————充足的知识储备、足够的简历投递数量、在面试中给对方留下印象与信心的能力、学校级别，这四点中随便一个没做好，就很难拿到offer。最终我在两个月的春招中一无所获，无论怎么和hr表达自己对广州的热爱，都无法阻挡他给我发感谢信的决心。在23年六月时，我也不相信自己半年时间只拿到两个offer，但前往杭州也是一个好的开始。</p>

<p>刚从学生身份转变为社会人的我，其实很能理解为什么孩子和长辈都会觉得自己比对方更累。在前年这个时候，父母承担了我的经济压力，除了怎么好好学习，憧憬未来以外没有什么东西需要考虑，偶尔会觉得学习压力比长辈们所面对的柴米油盐更大。而现在，我自己有了经济能力，需要独当一面解决各种问题：工作、赚钱、婚姻、养老，甚至于过年前开始想怎么从瘪瘪的钱包里变几个红包出来联系亲戚关系，又开始觉得以前学生时代更轻松，至少只需要做好一件事就够了。但人生就是这样每个阶段都有自己能做和需要做的事。人生是旷野吗？我无所谓，哪条路能让我和家人过的更好，我就一直走。</p>

<p>对于工作，我也算不上纯小白，至少24年初还实习了4个月。但不得不说，作为正职员工和作为实习员工在各种方面是完全不一样的。首先心理上，我实习时并没有什么太多的责任感和归属感，总想着大不了走人咯，而作为正职员工，我会想着要对产品、团队、公司负责，至少是尽量不要出错，也就是对自己负责。其次和同事相处时，我会更乐意和各种人交流，释放善意建立联系，大家也知道我比实习生更稳定，未来有更长的相处时间，也会更愿意帮助、培养我。在职场中我是很幸运的，在实习时遇到了很好的同事，在正式工作后也是。热情的主管，耐心的导师，友好的同事，让我对团队对公司都有了依赖。尽管现在大环境很差到处裁员，我在公司最好的应届生同事之一也要前程似锦了，我也不确定自己能在公司干多久，但这段经历作为职业生涯的开端绝对的美好而珍贵的。</p>

<p>愿君长似少年时，我用这句话作为工作钉钉的签名，想着提醒自己：少年的我总有些憧憬，不要忘了这些梦想与未来；少年的我总有些坚守，不要忘了这些善良和美好；少年的我总有些记忆，不要忘了这些旧人与教诲。初心不忘乐相知。</p>

<p>明年见。</p>]]></content><author><name>Lin</name></author><category term="杂谈" /><category term="杂谈" /><summary type="html"><![CDATA[愿君长似少年时，初心不忘乐相知。]]></summary></entry><entry><title type="html">Acdc数据集介绍与一篇医学图像分割综述读后记录</title><link href="/jekyll-theme-yat/2024/06/13/ACDC%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%B8%80%E7%AF%87%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E7%BB%BC%E8%BF%B0%E8%AF%BB%E5%90%8E%E8%AE%B0%E5%BD%95.html" rel="alternate" type="text/html" title="Acdc数据集介绍与一篇医学图像分割综述读后记录" /><published>2024-06-13T00:00:00+08:00</published><updated>2024-06-13T00:00:00+08:00</updated><id>/jekyll-theme-yat/2024/06/13/ACDC%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%B8%80%E7%AF%87%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E7%BB%BC%E8%BF%B0%E8%AF%BB%E5%90%8E%E8%AE%B0%E5%BD%95</id><content type="html" xml:base="/jekyll-theme-yat/2024/06/13/ACDC%E6%95%B0%E6%8D%AE%E9%9B%86%E4%BB%8B%E7%BB%8D%E4%B8%8E%E4%B8%80%E7%AF%87%E5%8C%BB%E5%AD%A6%E5%9B%BE%E5%83%8F%E5%88%86%E5%89%B2%E7%BB%BC%E8%BF%B0%E8%AF%BB%E5%90%8E%E8%AE%B0%E5%BD%95.html"><![CDATA[<h2 id="acdc数据集介绍">ACDC数据集介绍</h2>

<h3 id="1简介">1.简介：</h3>

<p>ACDC（Automated Cardiac Diagnosis Challenge）数据集是一个广泛用于心脏图像分割和诊断的公开数据集。通过ACDC数据集，研究人员可以开发和评估用于心脏图像分割、心脏功能分析和疾病诊断的算法和模型。这些研究有助于改进心脏疾病的诊断准确性和治疗效果，为临床实践提供更好的支持和指导。</p>

<h3 id="2挑战任务">2.挑战任务：</h3>

<p>（1）分割任务：比较不同方法在心脏舒张末期和收缩末期两个时间帧的心脏MRI图像上自动分割左心室、心肌、左心室的性能表现。（原文：compare the performance of automatic methods on the segmentation of the left ventricular endocardium and epicardium as the right ventricular endocardium for both end diastolic and end systolic phase instances）</p>

<p>（2）分类任务：将心脏状态分为五类，量化评估不同方法识别心脏病理状态的能力，其中心脏状态包括：正常情况、伴有梗死的心力衰竭、扩张型心肌病、肥厚型心肌病和右心室异常。（原文：compare the performance of automatic methods for the classification of the examinations in five classes normal case, heart failure with infarction, dilated cardiomyopathy, hypertrophic cardiomyopathy, abnormal right ventricle)</p>

<h3 id="3数据集包含信息">3.数据集包含信息：</h3>

<p>（1）数据集规模： 由150个来自Dijon大学医院的不同患者的心脏检查组成。数据集根据左、右舒张期容量或射血分数、左、右室局部收缩、左室质量、心肌最大厚度等生理参数明确分为5个均匀分布的子组（4个病理性群体和1个健康主体群体），其中训练集包含100个患者，测试集包含50个患者。</p>

<p>（2）患者文件夹内容： Info.cfg : 包含患者信息，数据对应心脏收缩、扩展对应帧，总帧数，病理分组。 Patient0xx_4d.nii.gz: 4d Cine-MRI，包含多个3D scan，体现完整心脏运动过程。 Patient0xx_frame01.nii.gz: ED帧的scan。 Patient0xx_frame01_gt.nii.gz: ED帧的scan的标记值。 Patient0xx_framexx.nii.gz: ES帧的scan。 Patient0xx_framexx_gt.nii.gz: ES帧的scan的标记值。</p>

<p>（3）标记值信息： 对于ACDC数据集中的每个像素，标签字段图像中的数值表示该像素所在的区域。具体来说：数值为0的像素位于背景区域。数值为1的像素位于右心室（RV）腔内。数值为2的像素位于心肌区域。数值为3的像素位于左心室（LV）腔内。（原文：Ground truth label field images were created where 0, 1, 2 and 3 represent voxels located in the background, in the RV cavity, in the myocardium, and in the LV cavity.）</p>

<p>（4）Info.cfg信息： ED: 表示该心脏图像序列中的心脏状态为舒张期（End Diastolic）的帧 ES: 表示该心脏图像序列中的心脏状态为收缩期（End Systolic）的帧。 Group: 表示该心脏图像序列所属的疾病分类。 Height: 表示心脏图像序列中患者的身高，单位为厘米。 NbFrame: 表示该心脏图像序列中的帧数，即包含的图像数量。 Weight: 表示心脏图像序列中患者的体重，单位为千克。</p>

<p>（5）Scan特性： 数据集只提供短轴切片，切片厚度在5毫米到10毫米之间（通常为5毫米），有时会有5毫米的间隙。空间分辨率在1.34至1.68 mm²/像素之间变化。 心脏成像切片位置示意图</p>

<h2 id="心脏图像分割review中心脏mri相关部分">心脏图像分割review中心脏MRI相关部分</h2>

<h3 id="1简介-1">1.简介</h3>

<p>论文标题为《Deep Learning for Cardiac Image Segmentation: A Review》，于2020年发表于Frontiers in Cardiovascular Medicine 期刊。论文对三种常见成像方式（MRI、CT、超声）中使用的深度学习技术进行了全面概述，涵盖了广泛的现有深度学习方法（主要是基于 CNN），这些方法旨在分割不同的心脏解剖结构（例如心脏心室、心房、血管）。此外，论文讨论了基于深度学习的心脏分割方法的未来潜力和剩余局限性。在本次阅读中，我主要阅读了MRI部分。</p>

<h3 id="2心脏分割任务包含的子结构及其生理作用">2.心脏分割任务包含的子结构及其生理作用：</h3>

<p>AO（主动脉）: 人体循环系统主要动脉之一 PA（肺动脉）：将贫氧血推送至肺部 PV（肺静脉）：将氧合血输送回心脏 RA（右心房）：接收来自循环系统的含有CO2的血液，输送至RV RV（右心室）：接收来自RA的血液，推送至肺动脉 LA（左心房）：接收肺静脉返回的氧合血，输送至LV LV（左心室）：接收来自LA的血液，推送至主动脉，输送全身 MYO（心肌）：心脏肌肉组织，通过收缩和舒张运动泵血 心脏结构图</p>

<h3 id="3cardiac-mr-image-心脏核磁共振成像介绍">3.Cardiac MR Image 心脏核磁共振成像介绍</h3>

<p>MRI技术属于非侵入性成像技术，用以可视化心脏内部与外围结构，具有无辐射性、软组织成像结果更精细；多序列成像，多图像类型，影像信息丰富等优点。心脏MRI成像常见方式有：Cine Imaging、Late Gadolinium Enhancement Imaging、Short Axis、Long Axis。目前，针对心脏分割任务展开研究的工作主要集中于心室分割，而心房分割、异常区域分割、主动脉分割、全心脏子结构分割相关工作数量较少。</p>

<h3 id="4各子结构分割任务临床意义">4.各子结构分割任务临床意义：</h3>

<p>（1）心室分割：帮助医生进行心脏疾病的诊断和治疗规划；心脏功能评估；对心室的定量分析，可以监测疾病的进展，评估治疗效果，并为疾病的早期诊断和预后评估提供依据；为手术导航和术中决策提供重要的信息。</p>

<p>（2）心房分割：在房颤消除手术计划和术后预期中帮助评估心房解剖结构；心房分割结果可作瘢痕分割和心房纤维化定量的基础。</p>

<p>（3）疤痕分割：识别心肌疤痕和心房纤维化，有助于改善心肌梗死和心房颤动的管理。</p>

<p>（4）主动脉分割：从cine MRI中分割出主动脉对于准确评估主动脉的机械和血流动力学特性至关重要。</p>

<p>（5）全心分割：提供准确的心脏解剖结构信息，帮助临床心脏疾病的诊断和治疗规划。</p>

<h3 id="5心室分割主要方法">5.心室分割主要方法</h3>

<p>（1）Vanilla* FCN-based segmentation：基础FCN及其拓展网络的应用。</p>

<p>（2）Introducing spatial or temporal context：引入额外先验信息指导网络分割任务。</p>

<p>（3）Applying anatomical constraints：引入解剖结构约束指导网络分割任务。</p>

<p>（4）Multi-task learning：执行与主分割任务相关的辅助任务。</p>

<p>（5）Multi-stage networks：将分割任务分解为多个子任务。</p>

<h3 id="6心脏分割任务面临的挑战">6.心脏分割任务面临的挑战</h3>

<p>（1）Scarcity of Labels：注释心脏图像非常耗时，而且通常需要大量的专业知识。</p>

<p>（2）Model Generalization Across Various Imaging Modalities, Scanners, and Pathologies：成像方式、扫描仪的多样导致数据集之间存在偏差，从而使各个数据集训练出的模型不够通用化。</p>

<p>（3）Lack of Model Interpretability：深度学习系统属于黑匣子，缺乏解释性。</p>

<h3 id="7review中所提到论文的收集方式">7.Review中所提到论文的收集方式</h3>

<p>作者在Scopus和PubMed等学术搜索引擎上进行了查询，搜索关键词包括了“convolutional”或“deep learning”、“cardiac”和“image segmentation”，并限定在标题或摘要中进行搜索。此外，还通过MICCAI、ISBI和EMBC等会议的论文集来搜索相关的文献。筛选过程中，将那些主要不关注分割问题的论文排除在外。最后一次更新检索的时间是2019年8月1日。</p>

<h3 id="8阅读体会总结">8.阅读体会总结</h3>

<p>从这篇review的MRI部分中，我清晰的了解了不同心脏分割工作的任务分类；全面的了解了2019年之前心室分割常用的方法；了解了心脏分割所面临的挑战；给论文写作中的研究意义攥写提供了指导方向。 《Deep Learning Based Cardiac MRI Segmentation: Do We Need Experts?》 实验设计</p>

<p>（1）简介 论文于2021年发表于Algorithms期刊。论文探讨了使用非专家标注来训练深度学习模型在心脏磁共振图像分割中的实用性。通过与非医学专业人员标注的数据进行比较研究，探讨了医学专家的必要性。通过将依赖非专家标注的问题定义为噪声数据，研究人员成功在两个公共数据集上取得了良好的性能，其中一个数据集用于模拟一个超出分布范围的数据集。研究发现，无论是使用U-Net、Attention U-Net还是ENet这样的容量不同的深度神经网络，使用经过良好训练的非专家标注的数据进行训练，其性能与专家标注的数据相当。此外，在超出分布范围的数据集上，非专家标注和专家标注的网络性能差距比训练数据集上的差距要小。论文表示未来的研究可以集中在大规模医学数据集并针对其噪声特点进行相应的方法优化。</p>

<p>（2）实验使用数据集 论文中使用了两个数据集：ACDC和M&amp;M。在ACDC数据集上，除了官方真值，额外制作了两个由非临床专家进行手工标记的标记值。论文使用一组固定的超参数、ACDC的训练集搭配三组不同的标记值训练分割模型。在测试阶段，论文使用包含50个患者的ACDC的测试集与150个患者的M&amp;M的训练集进行模型分割新能评估，M&amp;M被用于模拟一个不同分布的数据集。</p>

<p>（3）实验设置</p>

<p>     a)对比实验：专家、非专家标记在训练中对网络性能的影响</p>

<p>        i.表1展示了左心室的分割情况，将非专家标注（Non-Expert 1和Non-Expert 2）训练的网络与专家标注训练的网络进行量化比较，且对非专家标记训练网络设置了不同的损失函数组合，结果发现二者性能几乎持平，且这一结果不受损失函数影响。</p>

<p>         ii.表2展示了心肌的分割情况，结果发现非专家1制作的标记值训练出的网络性能差于专家，但非专家2制作的标记值训练出的网络新能与专家持平。</p>

<p>         iii.表3展示了右心室的分割情况，结果发现非专家1制作的标记值训练出的网络性能差于专家。此外，可以发现MAE+Dice损失函数改善了两位非专家的结果。</p>

<p>         iv.三个表格都展示了网络在M&amp;M数据集上的分割表现，并在图2中展示了M&amp;M数据集的分割可视化结果。论文发现所有网络对于M&amp;M的分割性能都表现出了不稳定性，在某些情况下，输出分割完全退化。M&amp;M数据集与ACDC的采集设置不同。在这种情况下，论文发现专家与非专家之间的性能差距大大减小。此外，无论使用哪种分割网络（U-Net、Attention U-Net或ENet），不同专业度标记值之间的分割性能差异是相似的，Attention U-Net整体上表现最好。</p>

<p>     b)进一步分析网络对心脏不同部位的分割性能 图3展示了不同专业标记值对于网络在基底部、中部和心尖部三个不同心脏部位的分割性能的影响，结果发现非专家和专家标记之间的差异主要集中在心脏的两个端部。性能差距在心尖部更为显著。 c)观察在不同病理分组中不同专业度标记值对网络性能的影响 图4展示了不同专业度标记值训练出的网络在不同疾病组内分割三个部位的Dice表现。结果发现不同专业度标记值和疾病组之间的Dice分数相对相似。</p>

<p>（4）阅读体会总结</p>

<p>该论文不针对方法进行创新，在实验设计上非常出色，定量、定性比较充分，完整展示了不同专业度标记值对于网络训练的影响，对我们的实验设计非常有参考价值。</p>]]></content><author><name>Lin</name></author><summary type="html"><![CDATA[ACDC数据集介绍]]></summary></entry><entry><title type="html">2023 年 度 总 结</title><link href="/jekyll-theme-yat/%E6%9D%82%E8%B0%88/2024/02/17/2023%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="2023 年 度 总 结" /><published>2024-02-17T00:00:00+08:00</published><updated>2024-02-17T00:00:00+08:00</updated><id>/jekyll-theme-yat/%E6%9D%82%E8%B0%88/2024/02/17/2023%E6%80%BB%E7%BB%93</id><content type="html" xml:base="/jekyll-theme-yat/%E6%9D%82%E8%B0%88/2024/02/17/2023%E6%80%BB%E7%BB%93.html"><![CDATA[<blockquote>
  <p>月有盈亏花有开谢，想人生最苦离别。 
花谢了三春近也，月缺了中秋到也，人去了何日来也？</p>
</blockquote>

<p>匆匆忙忙又是一年，恰如现在的我，临着明早九点半的动车，睡前想起今年还没作个交代，匆匆忙忙的从皮箱里拿出电脑开始写。</p>

<p>其实不太记得上半年发生了什么事情，估计是日子过得太悠闲，也没发生什么大事，就没有留下记忆点，想来每天的生活应该都是看看论文做做实验，玩玩游戏看看小说，应该还是后者居多。到了五月份之后实验做的差不多了就开始写论文，写到一半发现自己论文的idea和一个大佬有重合，就又开始匆匆忙忙的补实验完成论文，到了六月底和老师商量好之后投了一个ccfc会议，估计当时老师也不觉得我能中，于是为后来的意见相左留下了伏笔。</p>

<p>应该说是运气好，往年接受率只有19%的会议今年因为某些原因猛增到了30%，于是我意料之外的accepted了。不过导师不太高兴，觉得我这篇论文的水平应该为实验室拿个ccfb回来，我个人不太自信，主要还是考虑撤稿后如果那位大佬的论文被接受的话就很可能因为少了一个创新点而被拒稿，所以还是和导师商量了一下，最终同意保留，真的非常非常感谢老师的理解。</p>

<p>把研究生毕业的基本要求之一解决了之后，我踏入了另一个更重要的时期————应届秋招。和大部分提前了半年甚至一两年的人不同，我基本是裸考，基础也没怎么掌握，算法题也没怎么刷，就这么迷迷糊糊懒懒散散的进入九月，开始投简历。我的“努力”很快获得了相应的回报，在9到10月间我基本上没有几个面试，一方面是学校确实硬伤，一方面是没有实习经历，最最重要的是简历和大部分岗位JD的match程度较低，自己也不太自信，没有充足的配得感，于是有点emo的结束了秋招。</p>

<p>在十一月后我开始寻找实习机会，提前进入职场适应未来生活的同时为简历增加内容。机缘巧合下我去到合肥，在运气很好才能遇到的人又好能力又强的直系领导的引导下我完成了一些微不足道的任务，并明白了自己工作热情的来源之一是自我感觉有意义的工作，就像程序跑通结果正确的时刻、完成需求并成功交付给测试的时刻、自己派上了用场的时刻。在这两个月来最开心的是女朋友也来同一家公司实习，甚至是同一层办公室，一起上班吃饭下班，周末一起探索陌生的城市，真好，这日子真好。</p>

<p>只是我一直很焦虑，我知道自己很快就要离开合肥，只是实习的内容让我觉得生活忙碌而稳定，其实我毕业后的生活甚至是未知的，我希望能够找到一份满意的工作，心安理得的过完这三年最后的日子。</p>

<p>我基本上不会再有提升学历的机会了，所以随着三年的结束，我的学生生涯，我的有点漫长的青春终于不情不愿的走到了尽头。今年过年还非常幸运的住在住了21年的老家房子里，昨天收拾行李出门的时候，我想，我真不想离开这青春。</p>

<p>但是外面的世界已经向我走来了。</p>

<p>而我也要下定决心迈出步伐，向世界走去。</p>]]></content><author><name>Lin</name></author><category term="杂谈" /><category term="杂谈" /><summary type="html"><![CDATA[月有盈亏花有开谢，想人生最苦离别。 花谢了三春近也，月缺了中秋到也，人去了何日来也？]]></summary></entry><entry><title type="html">112. 路径总和 &amp;amp;&amp;amp; 113. 路径总和 II</title><link href="/jekyll-theme-yat/%E7%AE%97%E6%B3%95%E9%A2%98/2023/10/03/%E8%B7%AF%E7%BB%8F%E6%80%BB%E5%92%8C.html" rel="alternate" type="text/html" title="112. 路径总和 &amp;amp;&amp;amp; 113. 路径总和 II" /><published>2023-10-03T00:00:00+08:00</published><updated>2023-10-03T00:00:00+08:00</updated><id>/jekyll-theme-yat/%E7%AE%97%E6%B3%95%E9%A2%98/2023/10/03/%E8%B7%AF%E7%BB%8F%E6%80%BB%E5%92%8C</id><content type="html" xml:base="/jekyll-theme-yat/%E7%AE%97%E6%B3%95%E9%A2%98/2023/10/03/%E8%B7%AF%E7%BB%8F%E6%80%BB%E5%92%8C.html"><![CDATA[<h3 id="给你二叉树的根节点-root-和一个表示目标和的整数-targetsum-判断该树中是否存在-根节点到叶子节点-的路径这条路径上所有节点值相加等于目标和-targetsum-如果存在返回-true-否则返回-false-">给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。</h3>
<p><a href="https://leetcode.cn/problems/path-sum/description/">https://leetcode.cn/problems/path-sum/description/</a></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */</span>
</code></pre></div></div>

<h4 id="回溯--把根节点入栈开始遍历拿到顶端节点后把其出栈把其右节点入栈再把左节点入栈这样每次访问时先出栈就能让顶端存下往回走的每一个右节点">回溯  把根节点入栈，开始遍历，拿到顶端节点后把其出栈，把其右节点入栈，再把左节点入栈。这样每次访问时先出栈，就能让顶端存下往回走的每一个右节点。</h4>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">hasPathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">targetSum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">root</span><span class="p">;</span>
        <span class="n">stack</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">st</span><span class="p">;</span>
        <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">));</span>
        <span class="c1">// </span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">st</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
           <span class="n">pair</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span> 
           <span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="n">cur</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="n">targetSum</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
           
            <span class="k">if</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">cur</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">TreeNode</span><span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">cur</span><span class="p">.</span><span class="n">second</span> <span class="o">+</span> <span class="n">cur</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">));</span>
            <span class="p">}</span>
            
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h4 id="递归加回溯">递归加回溯</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">hasPathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">targetSum</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>   <span class="c1">// 递归，处理节点</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">sum</span> <span class="o">==</span> <span class="n">targetSum</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hasPathSum</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">targetSum</span><span class="p">))</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">sum</span> <span class="o">-=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>   <span class="c1">// 回溯，撤销处理结果</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="给你二叉树的根节点-root-和一个整数目标和-targetsum-找出所有从根节点到叶子节点-路径总和等于给定目标和的路径">给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有从根节点到叶子节点 路径总和等于给定目标和的路径。</h3>

<h4 id="递归加回溯-1">递归加回溯</h4>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">private:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">path</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">travelPath</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">travelPath</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">travelPath</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">count</span> <span class="o">-</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
            <span class="n">path</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">pathSum</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">targetSum</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">path</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="n">result</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="n">path</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="n">travelPath</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">targetSum</span> <span class="o">-</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>


</code></pre></div></div>

<h4 id="笔记">笔记：</h4>
<p>使用递归遍历二叉树解决问题时，什么时候递归函数需要返回值，什么时候不需要返回值(void)？</p>
<ol>
  <li>如果要搜索其中一条符合条件的路径，那么递归一定需要返回值；</li>
  <li>如果需要搜索整棵二叉树且不用处理递归返回值，递归函数就不要返回值；</li>
  <li>如果需要搜索整棵二叉树且需要处理递归返回值，递归函数就需要返回值。</li>
</ol>]]></content><author><name>Lin</name></author><category term="算法题" /><summary type="html"><![CDATA[给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。 https://leetcode.cn/problems/path-sum/description/]]></summary></entry><entry><title type="html">347.前k个高频元素</title><link href="/jekyll-theme-yat/%E7%AE%97%E6%B3%95%E9%A2%98/2023/09/15/%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html" rel="alternate" type="text/html" title="347.前k个高频元素" /><published>2023-09-15T00:00:00+08:00</published><updated>2023-09-15T00:00:00+08:00</updated><id>/jekyll-theme-yat/%E7%AE%97%E6%B3%95%E9%A2%98/2023/09/15/%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0</id><content type="html" xml:base="/jekyll-theme-yat/%E7%AE%97%E6%B3%95%E9%A2%98/2023/09/15/%E5%89%8Dk%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0.html"><![CDATA[<p>给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。
https://leetcode.cn/problems/top-k-frequent-elements/description/</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
    <span class="nl">public:</span>

        <span class="k">class</span> <span class="nc">mygreater</span><span class="p">{</span>
            <span class="nl">public:</span>
                <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pair1</span><span class="p">,</span> <span class="k">const</span> <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">pair2</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">pair1</span><span class="p">.</span><span class="n">second</span> <span class="o">&gt;</span> <span class="n">pair2</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
                <span class="p">}</span>
        <span class="p">};</span>
        
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">topKFrequent</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">nums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 获取元素出现频率</span>
            <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">umap</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="n">tmp</span> <span class="o">:</span> <span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">umap</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span> 

            <span class="c1">// 将元素和出现频率建立k个元素的小根堆</span>
            <span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span> <span class="n">mygreater</span><span class="o">&gt;</span> <span class="n">pq</span><span class="p">;</span>
            <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="n">umap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">umap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//不能用&lt;</span>
                <span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="o">*</span><span class="n">i</span><span class="p">);</span> 
                <span class="k">if</span> <span class="p">(</span><span class="n">pq</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">k</span><span class="p">){</span>
                    <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
            <span class="c1">// 将小根堆内元素存到result中</span>
            <span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">().</span><span class="n">first</span><span class="p">);</span>
                <span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
        <span class="p">}</span>
<span class="p">};</span> 
</code></pre></div></div>

<h2 id="笔记">笔记</h2>
<ol>
  <li>
    <p>priority_queue : C++标准库中的一个容器适配器，它基于堆（heap）数据结构实现，用于创建一个优先队列。优先队列是一种特殊的队列，其中元素被赋予优先级，按照优先级从高到低的顺序进行排序，允许高优先级的元素先出队。</p>
  </li>
  <li>
    <p>用迭代器遍历时候循环条件要用!= xx.end()， 而不是 &lt; 。</p>
  </li>
  <li>
    <p>priority_queue 的模板要求比较函数必须以类对象的形式存在，而不是直接的函数指针。且类不需要实例化，直接把类名放进去。</p>
  </li>
</ol>]]></content><author><name>Lin</name></author><category term="算法题" /><summary type="html"><![CDATA[给你一个整数数组 nums 和一个整数 k ，请你返回其中出现频率前 k 高的元素。你可以按 任意顺序 返回答案。 https://leetcode.cn/problems/top-k-frequent-elements/description/]]></summary></entry><entry><title type="html">LCR 017.最小覆盖子串</title><link href="/jekyll-theme-yat/%E7%AE%97%E6%B3%95%E9%A2%98/2023/09/15/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.html" rel="alternate" type="text/html" title="LCR 017.最小覆盖子串" /><published>2023-09-15T00:00:00+08:00</published><updated>2023-09-15T00:00:00+08:00</updated><id>/jekyll-theme-yat/%E7%AE%97%E6%B3%95%E9%A2%98/2023/09/15/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2</id><content type="html" xml:base="/jekyll-theme-yat/%E7%AE%97%E6%B3%95%E9%A2%98/2023/09/15/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2.html"><![CDATA[<h2 id="给定两个字符串-s-和-t-返回-s-中包含-t-的所有字符的最短子字符串如果-s-中不存在符合条件的子字符串则返回空字符串--如果-s-中存在多个符合条件的子字符串返回任意一个">给定两个字符串 s 和 t 。返回 s 中包含 t 的所有字符的最短子字符串。如果 s 中不存在符合条件的子字符串，则返回空字符串 “” 。如果 s 中存在多个符合条件的子字符串，返回任意一个。</h2>
<p>https://leetcode.cn/problems/M1oyTv/description/</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmap</span><span class="p">,</span> <span class="n">dymap</span><span class="p">;</span> <span class="c1">//tmap存t中字符出现频率，dymap存滑动窗口中字符频率</span>
    <span class="kt">bool</span> <span class="n">check</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">:</span> <span class="n">tmap</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span><span class="p">(</span><span class="n">dymap</span><span class="p">[</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">string</span> <span class="nf">minWindow</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="n">string</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
        
        <span class="kt">int</span> <span class="n">requireCount</span> <span class="o">=</span> <span class="n">t</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> 
        <span class="k">for</span><span class="p">(</span><span class="kt">char</span> <span class="n">tmp</span> <span class="o">:</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">tmap</span><span class="p">[</span><span class="n">tmp</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">int</span> <span class="n">minLength</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">ansl</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">tmpMap</span><span class="p">(</span><span class="n">tmap</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">tmap</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        
        <span class="k">while</span><span class="p">(</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">dymap</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">right</span><span class="p">]]</span><span class="o">++</span><span class="p">;</span>
             <span class="k">while</span><span class="p">(</span><span class="n">check</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">minLength</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">minLength</span> <span class="o">=</span> <span class="n">right</span> <span class="o">-</span> <span class="n">left</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                    <span class="n">ansl</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="k">if</span><span class="p">(</span><span class="n">tmap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">])</span> <span class="o">!=</span> <span class="n">tmap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
                    <span class="n">dymap</span><span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">left</span><span class="p">]]</span><span class="o">--</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">left</span><span class="o">++</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">right</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">ansl</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">?</span> <span class="n">string</span><span class="p">()</span> <span class="o">:</span> <span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">ansl</span><span class="p">,</span> <span class="n">minLength</span><span class="p">);</span>

    <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>使用滑动窗口策略。使用两个map分别储存t中字符出现频率和滑动窗口中字符频率。遍历s，只有当滑动窗口中包含了t中所有字符（判断条件为t中字符在滑动窗口中都存在且对应字符数量大于t（因为t中可能一个字符出现多次））才判断是否要更新最小子串长度（满足条件时先判断是否更新长度再更改left）。</p>]]></content><author><name>Lin</name></author><category term="算法题" /><summary type="html"><![CDATA[给定两个字符串 s 和 t 。返回 s 中包含 t 的所有字符的最短子字符串。如果 s 中不存在符合条件的子字符串，则返回空字符串 “” 。如果 s 中存在多个符合条件的子字符串，返回任意一个。 https://leetcode.cn/problems/M1oyTv/description/]]></summary></entry><entry><title type="html">2022 年 度 总 结</title><link href="/jekyll-theme-yat/%E6%9D%82%E8%B0%88/2023/01/26/2022%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="2022 年 度 总 结" /><published>2023-01-26T00:00:00+08:00</published><updated>2023-01-26T00:00:00+08:00</updated><id>/jekyll-theme-yat/%E6%9D%82%E8%B0%88/2023/01/26/2022%E6%80%BB%E7%BB%93</id><content type="html" xml:base="/jekyll-theme-yat/%E6%9D%82%E8%B0%88/2023/01/26/2022%E6%80%BB%E7%BB%93.html"><![CDATA[<blockquote>
  <p>我因为惧怕自己并非美玉，于是不敢刻苦琢磨，却又因为将信将疑地认为自己是一块美玉，于是不肯碌碌无为，与瓦砾为伍……事实上我哪有什么远大的志向，不过是害怕暴露自己对才能不足这种卑劣之事的恐惧，还害怕暴露自己对刻苦用功的怠惰而已。——《山月记》</p>
</blockquote>

<p>又是一年过去了，本来我还没有自己已经长大的觉悟，听到姨妈说表姐已经35岁，才猛地发现光阴如此易逝。 所幸，实现了年初的愿望，寻得佳人相伴，这便是对我来说一整年来最惊天动地的大事了。</p>

<p>一直以来，我并没有乡愁之情，但由于暑假没有回家的缘故，我离家九月有余，这是我身处异地时间最长的一段时光，中秋节时，看着月亮，觉得落叶归根的想法十分浪漫。想想后面的日子，我也要准备真正意义上进入社会了，或许未来一年里想家的日子会越来越久，睡前躺在床上，想吃春饼卷、四果汤、面线糊的机会也会越来越多。有时候觉得日子过得很快，有时候又觉得假期来的太慢，这就是属于游子的相对论吧。</p>

<p>说实在的，我需要检讨，过去的一年中又充分放纵了自己的懒惰，并没能拿出什么成绩。原本夸下海口，年末发出论文，结果连实验都还没开始做，后来才明白，拖延的原因便是害怕自己不能够得到足以支撑论文的实验结果，甚至是没有完成项目代码的能力。在这里，我不敢说自己将实践怎样怎样的计划，达成什么样的目标，只是我自己必须要明白，有些事一定是要做的，一定要想明白要怎么做，然后去付诸实践。我想很多人跟我一样因为害怕面对自己可能没有足够才能的事实而一再的逃避，但是越挫越勇的小人物才有机会达成目标。做人，一定不能骗自己。</p>

<p>想要总结以年为单位的时间跨度，或许讲述变化会更加合适。</p>

<p>我不再称呼自己为牡丹，不再想象谈恋爱的未来，现在的一点一滴才需要我细细品味。感谢我的女友，现在已经在一起283天，我发觉这些日子让自己有了许多改变，并在某一天的夜里毅然决然的接受自己已不是男孩的现实。希望未来能够成为足够坚实的臂膀，与你相伴于山海。</p>

<p>我们从金鸡岭搬进了花江，大了好多倍的校园我实在不喜欢，一个月充一次电的电动车改为一周一充，而且充电位置十分抢手，太麻烦了，偏偏实验室离宿舍非常远，偏偏风很大也很冷。</p>

<p>2023年是需要努力学习的一年，需要完成：发论文，找实习，找工作。加油吧同志们。</p>

<p>不过现在呢，管他呢，开心就好。</p>]]></content><author><name>Lin</name></author><category term="杂谈" /><category term="杂谈" /><summary type="html"><![CDATA[我因为惧怕自己并非美玉，于是不敢刻苦琢磨，却又因为将信将疑地认为自己是一块美玉，于是不肯碌碌无为，与瓦砾为伍……事实上我哪有什么远大的志向，不过是害怕暴露自己对才能不足这种卑劣之事的恐惧，还害怕暴露自己对刻苦用功的怠惰而已。——《山月记》]]></summary></entry><entry><title type="html">MECAT简要介绍</title><link href="/jekyll-theme-yat/%E7%AC%94%E8%AE%B0/2022/06/24/MECAT%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D.html" rel="alternate" type="text/html" title="MECAT简要介绍" /><published>2022-06-24T00:00:00+08:00</published><updated>2022-06-24T00:00:00+08:00</updated><id>/jekyll-theme-yat/%E7%AC%94%E8%AE%B0/2022/06/24/MECAT%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D</id><content type="html" xml:base="/jekyll-theme-yat/%E7%AC%94%E8%AE%B0/2022/06/24/MECAT%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D.html"><![CDATA[<h2 id="mecat-fast-mapping-error-correction-and--de-novo-assembly-for-single-molecule-sequencing-reads">MECAT: fast mapping, error correction, and  de novo assembly for single-molecule sequencing reads</h2>

<h2 id="一-简介">一、 简介</h2>
<p>MECAT由中山大学的Chuan-Le Xiao团队研发，其论文于2017年发表于《nature》。</p>

<p>MECAT是一个基于比对纠错的组装工具,获取基因序列后将其分割为多个长读段，并建立索引表，通过其原创的比对算法获取读段间的overlapping，使用比对结果进行纠错操作，最终将纠错完成的长读段进行组装，输出一整条基因序列。</p>

<p>论文中提到，工具的主要创新点是： <strong>提出一套伪线性对齐评分算法（pseudolinear alignment scoring algorithm）来过滤过多的对齐，节省计算资源,大大减少运行速度。</strong></p>

<p>Chuan-Le Xiao团队针对MECAT的各项性能指标设计了大量的实验，最终结果清晰的说明：MECAT工具的比对速度数倍高于其他方法，敏感度与运行效率平衡极佳，所需运行资源非常少，非常适合进行规模较小的基因序列比对、纠错、组装工作。</p>

<p><a href="https://www.nature.com/articles/nmeth.4432#citeas">论文地址</a></p>

<p><a href="https://github.com/xiaochuanle/MECAT">项目地址</a></p>

<p><a href="https://static-content.springer.com/esm/art%3A10.1038%2Fnmeth.4432/MediaObjects/41592_2017_BFnmeth4432_MOESM1_ESM.pdf">论文补充材料地址</a></p>

<h2 id="二方法介绍">二、方法介绍</h2>

<h2 id="一-indexing-and-matching-of-reads-建立索引寻找匹配">(一) Indexing and matching of reads 建立索引&amp;寻找匹配</h2>

<p>MECAT寻找读段之间的潜在匹配是基于读段之中的k-mers（长度为k的子字符串），长度为L的读段总共有L-k+1个k-mer。算法首先使用k-mers作为key，k-mer在读段片段中的位置作为value，建立哈希表，对整个读段进行索引。关于片段，算法将每个读段分割为多个block，每个block的长度为B，其值通常为1000~2000bp。</p>

<p>当我们有一条待比对长读段，需要找到与它存在匹配的(相同)读段所在的位置，就扫描待比对长读段中的k-mers，并用其于哈希表中获取匹配的k-mer的位置，这些k-mer位于其他区域。为了减少运行时间，算法对于待比对长读段中的k-mers进行采样：使用长度为sl的滑动窗口，沿着当前所在的block滑动，每次滑动时取从滑动窗口头部开始的k-mer，并将滑动窗口从头部移动到尾部。经过采样，最终得到的k-mers数量约为整个读段中k-mers总数的1/sl（sl的默认值为10）。如若一个待比对的block和另一个block之间存在匹配k-mers，且数量大于预定义的阈值m，则两个block被判定为相互匹配；若两个读段中至少存在一对block相互匹配，则这一对读段被判定为相互匹配。</p>

<p>论文中还论述了一对匹配的block中相互匹配的k-mers的期望数量，具体内容请自行阅读论文。</p>

<p><img src="https://i.imgur.com/ovHp56x.png" alt="图1" /></p>

<h2 id="二-filtering-false-matched-reads-using-the-distance-difference-factor-score-过滤过多匹配">(二) Filtering false-matched reads using the distance difference factor score 过滤过多匹配</h2>

<p>MECAT提出了一种原创的伪线性评分算法来过滤大量的弱信息匹配读段，被过滤的block不进行计算考察。评分算法包含两个步骤：相互评分（mutual scoring）和拓展计算（extension scoring）。<br /><br />
在相互评分中，算法首先在相互匹配的读段中随机选择一对匹配的block，并block进行标记，然后对其中匹配的k-mers对进行打分。打分的公式如下：</p>

<table>
  <tbody>
    <tr>
      <td>$$DDF_{i,j}=</td>
      <td>1-\frac{p_i-p_j}{p_i^{‘}+p_j^{‘}}</td>
      <td>$$</td>
    </tr>
  </tbody>
</table>

<p>其中$p_i,p_j$代表block中第i、j个k-mer的位置，而${p_i}^{‘}，{p_j}^{‘}$代表另一个block中第i、j个k-mer的位置。公式中分数代表了这一对k-mer在两个不同的block中相对位置是否相同/近似，若近似则可以认为这一对k-mer更有可信度。</p>

<p>对于一对k-mers的DDF值若小于阈值ε（默认设为0.3），则表示这两个k-mers相互支持对方的可信度，于是将两个k-mers的分数都加一，在所有k-mers都两两成对完成DDF计算后，将分数最高的k-mer作为这一block内的seed，以进行下一步操作。需要注意的是，若一个k-mers在哈希表中能找到多个匹配项，则不置入计算。</p>

<p><img src="https://i.imgur.com/PuLZVcS.png" alt="图 4" /></p>

<p>当一个block中出现了seed后，算法将开始对其进行拓展计算：将与该blcok相邻的的存在匹配的block1中的每一个存在匹配的k-mer，都与block的seed两两成对，计算DDF值，如若值小于阈值ε，则将seed的分数加一。当block1中至少80%存在匹配的k-mer与seed成对的DDF都小于阈值ε，则标记block1，此后不再对其进行评分计算。当一次相互评分与拓展计算循环结束后，读段中仍然存在尚未标记的存在匹配的block，则在其中随机选择一个开始评分计算。</p>

<p><img src="https://i.imgur.com/tjq3xa8.png" alt="图 5" /></p>

<p>相互评分与拓展计算的时间复杂度分别为$O(N^2)$、$O(N)$，其中N代表与k-mer的匹配数。由于相互评分过程中k-mers的数量较少，所以整个评分过程可以在伪线性时间复杂度内完成。</p>

<h2 id="三-pairwise-alignment-of-single-molecule-sequencing-reads-单因子序列读段的成对比对">(三) Pairwise alignment of single-molecule sequencing reads. 单因子序列读段的成对比对</h2>

<p>在成对比对中，算法将每个block的长度设置为2000bp。当两个读段完成了计算，所有block都进行了标记后，算法将读段中的k-mers按照分数进行排序，使用top-rank的mers作为seed，对这一对读段进行局部比对（local alignment）。如若两个单分子序列读段的重叠区域长度都大于2000bp，且重叠序列的错配率（mismatch rate）两倍小于读段的错误率（error rate），则判定这一对读段相互匹配，最后将比对结果输出。</p>

<h2 id="四aligning-single-molecule-sequencing-reads-to-a-reference-genome-单因子序列读段比对到参考基因组">(四)Aligning single-molecule sequencing reads to a reference genome. 单因子序列读段比对到参考基因组</h2>

<p>读段比对到参考基因组的工作与读段两两比对较为类似，区别主要在于前者多了一个根据不同情况设置block长度的策略，以及一个针对k-mers进行采样的滑动窗口策略。</p>

<p>算法首先将参考基因组分成长度为B的block，并使用其中k-mers建成索引表，然后将读段也分成长度为B的block，对其中的k-mers进行采样，并在索引表中搜索这些k-mers，找出匹配的block，对其施加前面提到的比对策略。完成读段中所有block的评分操作后，将所有k-mers按评分进行排序，使用top-rank mers作为种子进行局部比对。</p>

<p>读段与参考基因组的比对工作有两个步骤以应对参考基因组过长导致的比对效果不佳等问题。在第一步中，算法将block长度B设为1000bp，k-mers采样滑动窗口的长度sl设置为20而进行比对，但有一部分block中存在匹配的k-mers数量较少，或是分布不均匀，所以无法找到匹配项。在第二步中，算法将B设为2000bp，将sl减小到10，然后重新比对在第一部中没有完成匹配的block。</p>

<p>由于在上述的两个步骤中，第一个步骤能找出读段内大部分block的匹配项，且第一步所需的计算资源小于第二步，所以这个策略能在保持比对精度的基础上减少资源占用。</p>

<p>该部分论文还对读段中局部结构的修剪策略做了论述，如有需要请自行查阅。</p>

<h2 id="五correcting-single-molecule-sequencing-reads单分子序列读段纠错">(五)Correcting single-molecule sequencing reads.单分子序列读段纠错</h2>

<p>在MECAT中，读段纠正包含两个步骤，第一个是在读段中采用成对比对，第二个是根据一个读段的共识表来构建正确读段。下面进行具体说明。</p>

<p>在第一步中，算法把将要进行校正的读段称为template read。对于要进行校正的template read，将其与所有匹配读段进行DDF计算，把这些匹配读段根据其中的k-mers分数进行排序，然后从高到低进行局部比对。需要注意的是，在寻找匹配项的过程中，如果两个读段重叠部分的长度小于其中较短读段的90%，则舍弃这个匹配读段，以消除嵌合读段和重复子序列（chimeric reads and repeat subsequences）的影响。</p>

<p>文中提到，一旦收集到100个overlap或template read的所有匹配读段，比对操作就会停止，且由于DDF得分能粗略估计overlap的长度，所以根据DDF分数从高到底进行局部比对能提高效率，避免计算无信息的重复overlap，加快校正。关于DDF分数能够估计overlap长度的说法，我个人的理解是，这里的DDF分数指的是读段内所有k-mers的在比对操作过程中不断累加，最终得到的分数，分数由k-mers相互比对得来，值越高就说明k-mers数量越多，那么重叠长度也就越长，所以DDF分数才能粗略估计重叠长度。</p>

<p><img src="https://i.imgur.com/dZaQruS.png" alt="图 8" /></p>

<p>在第二步中，MECAT结合了其他两个工具——DAGCon和FalconSense的原理，提出了一种自适应单分子读取错误校正策略。算法使用在第一步中template read与匹配读段进行局部比对所得到的信息构建了一个共识表（consensus table），其中包括读段每个位置上碱基的比对信息，这些信息是匹配、插入和删除操作的计数统计值。有上图中比对信息构成的共识表如下图。其中mat代表match，del代表deletion，ins代表insertion，base代表碱基。</p>

<p><img src="https://i.imgur.com/NP4cgGE.png" alt="图 6" /></p>

<p>在完成共识表后，MECAT根据其中的信息将template read分成三个区域：</p>

<p>不重要区域：$\frac{match}{match+deletion} &gt; 0.8$ &amp;&amp; $insertion &lt; 6 $</p>

<p>删除区域：$\frac{deletion}{match+deletion} &gt; 0.8$ &amp;&amp; $insertion &lt; 6 $</p>

<p>复杂区域： $insertion \geq 6$</p>

<p>通过分区获得的共识结果（consensus result）如下图所示。</p>

<p><img src="https://i.imgur.com/BhQ1PxS.png" alt="图 8" /></p>

<p>算法针对三种区域有不同的处理方法，其中匹配区域完整保留，不做处理；删除区域直接去除，不留gap；复杂区域则使用DAGCon的原理，通过建立DOG来得到共识序列（consensus sequence）。获得共识序列的操作如下图所示。</p>

<p><img src="https://i.imgur.com/Gebeozs.png" alt="图 7" /></p>

<p>根据共识区域将复杂区域填充后，得到最终序列，如下图所示</p>

<p><img src="https://i.imgur.com/IWg6JDv.png" alt="图 9" /></p>

<p>该部分论文还说明了MECAT优化硬件的策略，有需要请自行查阅。</p>

<h2 id="六de-novo-assembly-using-single-molecule-sequencing-reads从头组装单分子序列读段">(六)De novo assembly using single-molecule sequencing reads.从头组装单分子序列读段</h2>

<p>MECAT组装策略分为三步：</p>

<ul>
  <li>对于每一条read，将其与其他read进行成对比对，在这过程中不进行局部比对，而是根据DDF分数高低来选择出前100条与其最匹配的read</li>
  <li>对于每一条read，使用其匹配的reads来对它进行纠错</li>
  <li>对经过的纠错的reads进行成对比对，并将比对结果输入到 Canu  (v1.0)  的Unitig Construction模块来将读段组装为unitigs.</li>
</ul>

<h3 id="mecat工具安装较为繁杂且其中存在bug建议直接安装mecat2集成度比较高更容易使用">MECAT工具安装较为繁杂，且其中存在BUG，建议直接安装MECAT2，集成度比较高，更容易使用。</h3>
<h3 id="mecat2项目地址httpsgithubcomxiaochuanlemecat2">MECAT2项目地址：<a href="https://github.com/xiaochuanle/MECAT2">https://github.com/xiaochuanle/MECAT2</a></h3>

<h3 id="谢谢再会">谢谢，再会！</h3>]]></content><author><name>Qi、Lin</name></author><category term="笔记" /><summary type="html"><![CDATA[MECAT: fast mapping, error correction, and de novo assembly for single-molecule sequencing reads]]></summary></entry><entry><title type="html">基于natapp的内网穿透</title><link href="/jekyll-theme-yat/%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/2022/01/12/%E5%9F%BA%E4%BA%8Enatapp%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html" rel="alternate" type="text/html" title="基于natapp的内网穿透" /><published>2022-01-12T00:00:00+08:00</published><updated>2022-01-12T00:00:00+08:00</updated><id>/jekyll-theme-yat/%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/2022/01/12/%E5%9F%BA%E4%BA%8Enatapp%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F</id><content type="html" xml:base="/jekyll-theme-yat/%E6%93%8D%E4%BD%9C%E7%AC%94%E8%AE%B0/2022/01/12/%E5%9F%BA%E4%BA%8Enatapp%E7%9A%84%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F.html"><![CDATA[<p>​	寒假在家里想做作业，奈何带回来的超极本一跑模型就黑屏重启。想到可以用实验室的服务器，但是在非校园网下没办法直接访问，而通过远程控制实验室的电脑来连接又很容易断网失联。在王师兄的建议下尝试了使用内网穿透技术来从外网连接服务器。以下是操作步骤，仅供参考，不一定正确！</p>

<h3 id="一安装natapp">一.安装natapp</h3>

<p>​	下载页面链接：https://natapp.cn/#download</p>

<p>​	在下载页面中选择Linux 64位版本，得到一个natapp文件，可以使用xftp等手段将该文件上传到目标服务器中。</p>

<h3 id="二配置隧道">二.配置隧道</h3>
<p>​	可以选择使用免费隧道，但是很不好用，每次重开natapp进程都会重新随机分配端口，使得我们本地的xshell之类的软件的配置都需要更改。我是买了一个月的VIP_3型隧道来用，可以自己设定端口号（只有一次机会）。配置的时候将服务器的ip地址输入到“本地地址”中，本地端口设置为22。（一定要记得输入正确的服务器ip地址，不然会出现“Connection closed by foreign host”的问题）
​	<img src="https://i.imgur.com/eMVfpFy.png" alt="图 1" /></p>

<h3 id="三在服务器上开启natapp">三.在服务器上开启natapp</h3>
<h4 id="1cd到natapp文件所在的目录">1.cd到natapp文件所在的目录</h4>
<h4 id="2更改natapp执行权限">2.更改natapp执行权限</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>chmod a+x natapp
</code></pre></div></div>
<h4 id="3创建虚拟会话以达到natapp进程持续运行的目的">3.创建虚拟会话以达到natapp进程持续运行的目的</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>screen -dmS natapp    #创建会话
screen -r natapp	  #连接会话
</code></pre></div></div>
<h4 id="4运行natapp">4.运行natapp</h4>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./natapp -authtoken=(隧道的authtoken)
</code></pre></div></div>
<p>​	看到online信息就OK了，在NATAAPP网页里也可以看到隧道已经在线。（可能有延迟）</p>
<h4 id="5可以选择直接关掉xshell因为我不知道怎么退出虚拟会话所以只好整个关">5.可以选择直接关掉xshell（因为我不知道怎么退出虚拟会话所以只好整个关）</h4>

<p>补充：如果失误打开了两个screen的虚拟会话session，可以使用以下命令关闭：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>screen -S (session-name) -X quit
</code></pre></div></div>

<h3 id="三登录">三.登录</h3>
<p>​	使用隧道提供的地址和端口去xshell直接连接就行，没有问题的话可以看到连接建立的信息。</p>

<p>​	说实话1M的速度限制下想要向服务器上传文件是有点慢，但是直接在服务器下载也不是不行啦。好了，可以直接在外网访问服务器了，作业要咋做还没想好哈哈哈。</p>]]></content><author><name>Lin</name></author><category term="操作笔记" /><summary type="html"><![CDATA[​ 寒假在家里想做作业，奈何带回来的超极本一跑模型就黑屏重启。想到可以用实验室的服务器，但是在非校园网下没办法直接访问，而通过远程控制实验室的电脑来连接又很容易断网失联。在王师兄的建议下尝试了使用内网穿透技术来从外网连接服务器。以下是操作步骤，仅供参考，不一定正确！]]></summary></entry><entry><title type="html">2021 年 度 总 结</title><link href="/jekyll-theme-yat/%E6%9D%82%E8%B0%88/2022/01/06/2021%E6%80%BB%E7%BB%93.html" rel="alternate" type="text/html" title="2021 年 度 总 结" /><published>2022-01-06T00:00:00+08:00</published><updated>2022-01-06T00:00:00+08:00</updated><id>/jekyll-theme-yat/%E6%9D%82%E8%B0%88/2022/01/06/2021%E6%80%BB%E7%BB%93</id><content type="html" xml:base="/jekyll-theme-yat/%E6%9D%82%E8%B0%88/2022/01/06/2021%E6%80%BB%E7%BB%93.html"><![CDATA[<p>好了，时间来到了2022年，我离开我温暖的老家已经一周年。新家离老家70公里，也就是这70公里让我感到70倍的孤独，甚至我家离市中心还有10公里，而我在这个片区唯三能够玩耍的朋友全在市区。以前我非常期待放假，现在我甚至不想回家。在学校每天都和朋友和同学在一起，想找独处的时间其实都有点困难。挺好的。如果以后有机会，我还是想回永春，我的老家永春，承载了我21年回忆的永春，满是我亲朋好友的永春。</p>

<p>​	2021年应该可以算是我人生的又一个转折点，考研上岸又给了我额外的三年学校时光，让我能够以更加成熟的心性和更加完善的能力去成为一个社畜。我是一个很念旧的人，我也是一个对家乡很有依恋的人。本来我也是打算上华大，毕竟离家这么近，周末回家都只要半小时高铁，结果命运使然，让我在水群的时候碰到了来给导师招生的王哥，然后异常顺利的去了广西。广西是那么远，让我昨天坐了一小时车从学校到机场，两个小时飞机从桂林到厦门，一个小时brt+高铁从厦门到泉州……太累了，太久了。听说硕士阶段没有暑假？那我一年如果没有其他事情顶多只能回家两到三次，而且其中只有寒假是比较长的。我也打算毕业后去大厂打工，那福建又没有大厂，好了，我竟然突然之间成了游子，以后得好好努力挣钱，等挣够了买房的钱就回福建结婚，希望能在30岁回到家乡，回到我可爱的闽南。</p>

<p>​	最后聊一聊研一这半个学期吧。首先桂电金鸡岭的宿舍真的是破到让我破防，当是9月还热的要死，我头一天在宿舍整宿睡不着觉，都2021年了还没有空调的学校宿舍简直感动中国，没有办法只能去外面合租了一个套房，算是把住宿问题解决了。但是12月7号的时候桂林突然出来一个阳性的偷渡犯，跑来到处逛，搞得学校直接封校，我们只能又搬了回来，然后住了几天我发现宿舍只要不用到空调，住起来还是很舒服的，也让我跟舍友慢慢熟悉了起来。我运气真的不错的，本科和硕士阶段遇到的舍友都挺好相处。实验室环境感觉挺好的，氛围也非常不错。导师挺尊重我们，我们都很尊敬老师，可以说当时选老师选的非常正确，同门也都很好，师兄师姐们带我们一起玩，帮我们解决学习问题，同门也都在一起风雨同舟，可以说是爱住了3304-1。</p>

<p>​	硕士阶段要上课是真的很烦，为了在一学期内解决所有能解决的学分要求，我直接把课程进行一个全部的选，结果就是平时上课时间多，考试周压力大到爆。一周5门考试是什么玩意儿，梦回高中了家人们，还全是复习压力有点大的课，比考研压力都大。也不知道是不是考研留下的后遗症，现在我考试前都焦虑的要死，一直冷静不下来，担心挂科，明明我本科的时候都很从容的面对考试。还好，最后考的成绩还算可以，到目前为止还有两门课程没有出，希望不要绝杀我，直接让我挂科了，求求求求求求求。</p>

<p>​	至于2022年，希望我能一直保持努力的劲头，拒绝躺平，为美好明天继续奋斗!	（PS：交个女朋友）</p>

<p>​</p>]]></content><author><name>Lin</name></author><category term="杂谈" /><category term="杂谈" /><summary type="html"><![CDATA[好了，时间来到了2022年，我离开我温暖的老家已经一周年。新家离老家70公里，也就是这70公里让我感到70倍的孤独，甚至我家离市中心还有10公里，而我在这个片区唯三能够玩耍的朋友全在市区。以前我非常期待放假，现在我甚至不想回家。在学校每天都和朋友和同学在一起，想找独处的时间其实都有点困难。挺好的。如果以后有机会，我还是想回永春，我的老家永春，承载了我21年回忆的永春，满是我亲朋好友的永春。]]></summary></entry></feed>